<?php
/**
 * DomainsApi
 * PHP version 5
 *
 * @category Class
 * @package  Mittwald\Api
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Schnittstellen für Mittwald-Kunden
 *
 * >**Für die öffentliche API, alle Bestandteile und diese Dokumentation bieten wir keinen Support. Wir behalten uns vor, Änderungen jederzeit und ohne Ankündigung oder Dokumentation durchzuführen.**  Authentifizierung -----------------  ### Mit Nutzername & Passwort  Zur Authentifizierung wird ein zuvor ausgestelltes API-Token benötigt. Bei Requests kann dieses Token innerhalb eines `Authorization`-Headers übergeben werden:  ```http GET /v1/customers/123456 HTTP/1.1 Host: api.mittwald.de Authorization: Bearer {TOKEN-HIER-EINFÜGEN} ```  Alternativ dazu kann das Token auch in Form des Query-Parameters `access_token` übergeben werden:      GET /v1/customers/123456?access_token={TOKEN-HIER-EINFÜGEN} HTTP/1.1     Host: api.mittwald.de  Um ein Token zu beziehen, kann der `/authenticate`-Endpunkt genutzt werden. Hier erfolgt eine Authentifzierung über die Zugangsdaten des Mittwald-Kundencenters.      POST /v1/authenticate HTTP/1.1     Host: api.mittwald.de     Content-Type: application/json     Accept: application/jwt      {         \"username\": \"r1234\",         \"password\": \"{PASSWORT-HIER-EINFÜGEN}\"     }  Rückgabewert dieses Aufrufs ist ein API-Token. Dieses hat eine begrenzte Gültigkeitsdauer.  **Wichtig**: Client-Applikationen sollten das API-Token für seine Gültigkeitsdauer cachen, und erst *anschließend* ein neues Token über die API anfordern.  ### Mit Access-Token  Für Anwendungen, die dauerhaft Zugriff auf die Mittwald-API benötigen, wird nicht empfohlen, Nutzername und Passwort dauerhaft in der jeweiligen Anwendung zu speichern. Stattdessen empfehlen wir den Einsatz eines Access Tokens, welches nach einem (initialen) Login mit Nutzername und Passwort erstellt und im Anschluss anstelle dessen genutzt werden kann.  Hierzu wird zunächst ein reguläres API-Token benötigt, das per Nutzername und Passwort bezogen werden kann. Weder Nutzername+Passwort noch das damit bezogene API-Token müssen dauerhaft gespeichert werden. Sie dienen lediglich dazu, ein Access Token zu erstellen, welches im Anschluss dauerhaft in der Applikation gespeichert werden kann:  ``` POST /v1/authentication/tokens HTTP/1.1 Host: api.mittwald.de Content-Type: application/json  {   \"description\": \"Meine Anwendung\" } ```  In der Antwort auf obige Anfrage ist das eigentliche Access Token und dessen ID enthalten (mit Beispiel-Daten):  ``` HTTP/1.1 201 Created Content-Type: application/json  {   \"uuid\": \"2a91ce52-2058-404b-9959-ac7d2fbbbfbc\",   \"token\": \"MW_aEQyz5j9YmTaamTq2N9X3d2sBDACLUoz\",   \"crdate\": \"2021-08-23T14:06:17.580Z\",   \"description\": \"Meine Anwendung\" } ```  `uuid` und `token` dieser Antwort können bei nachfolgenden Authentifzierungs-Vorgängen als Nutzername und Passwort genutzt werden.  Rate Limiting -------------  Zur Sicherstellung der Systemstabilität sind einige API-Endpunkte in der Anzahl der durchführbaren Anfragen beschränkt. Die Limitierung bezieht sich dabei stets auf ein Zeitfenster von 15 Minuten.  Bei auf diese Weise zugriffsbeschränkten API-Endpunkten enthalten die HTTP-Antworten stets einen `X-RateLimit`-Header, welcher die maximale Anzahl der ausführbaren Anfragen enthält. Außerdem enthält jede Antwort einen `X-RateLimit-Remaining`-Header, welcher die aktuell noch verfügbaren Anfragen enthält:      HTTP/1.1 200 OK     Content-Type: application/json;charset=utf8     Content-Length: 1234     X-RateLimit: 1000     X-RateLimit-Remaining: 712  Caching -------  Einige Anfragen an die API können zwecks besserer Performance aus einem serverseitigen Cache beantwortet werden. Wurde eine Anfrage aus dem Cache beantwortet, enthält die Antwort einen `X-Cache: HIT`-Header.  Der Cache einer Ressource wird dann geleert, wenn ein `POST`-, `PUT`- oder `DELETE`-Request an dieselbe URI gesendet wird, oder bei einem `GET`-Request ein `Cache-Control: no-cache`-Header gesendet wird.
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.54
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Mittwald\Api\Functions;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Mittwald\Api\ApiException;
use Mittwald\Api\Configuration;
use Mittwald\Api\HeaderSelector;
use Mittwald\Api\ObjectSerializer;

/**
 * DomainsApi Class Doc Comment
 *
 * @category Class
 * @package  Mittwald\Api
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class DomainsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation checkDomainAvailability
     *
     * Domainverfügbarkeit prüfen
     *
     * @param  string $domain_identifier Domain (required)
     *
     * @throws \Mittwald\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function checkDomainAvailability($domain_identifier)
    {
        $this->checkDomainAvailabilityWithHttpInfo($domain_identifier);
    }

    /**
     * Operation checkDomainAvailabilityWithHttpInfo
     *
     * Domainverfügbarkeit prüfen
     *
     * @param  string $domain_identifier Domain (required)
     *
     * @throws \Mittwald\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function checkDomainAvailabilityWithHttpInfo($domain_identifier)
    {
        $returnType = '';
        $request = $this->checkDomainAvailabilityRequest($domain_identifier);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation checkDomainAvailabilityAsync
     *
     * Domainverfügbarkeit prüfen
     *
     * @param  string $domain_identifier Domain (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkDomainAvailabilityAsync($domain_identifier)
    {
        return $this->checkDomainAvailabilityAsyncWithHttpInfo($domain_identifier)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation checkDomainAvailabilityAsyncWithHttpInfo
     *
     * Domainverfügbarkeit prüfen
     *
     * @param  string $domain_identifier Domain (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkDomainAvailabilityAsyncWithHttpInfo($domain_identifier)
    {
        $returnType = '';
        $request = $this->checkDomainAvailabilityRequest($domain_identifier);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'checkDomainAvailability'
     *
     * @param  string $domain_identifier Domain (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function checkDomainAvailabilityRequest($domain_identifier)
    {
        // verify the required parameter 'domain_identifier' is set
        if ($domain_identifier === null || (is_array($domain_identifier) && count($domain_identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain_identifier when calling checkDomainAvailability'
            );
        }

        $resourcePath = '/domains/{domainIdentifier}/actions/check';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($domain_identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'domainIdentifier' . '}',
                ObjectSerializer::toPathValue($domain_identifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createSubdomain
     *
     * Subdomain erstellen
     *
     * @param  \Mittwald\Api\Model\SubdomainCreationBody[] $body Daten der neuen Subdomain (required)
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     * @param  string $domain_identifier Vollständiger Name der Domain (required)
     *
     * @throws \Mittwald\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Mittwald\Api\Model\Subdomain[]
     */
    public function createSubdomain($body, $account_identifier, $domain_identifier)
    {
        list($response) = $this->createSubdomainWithHttpInfo($body, $account_identifier, $domain_identifier);
        return $response;
    }

    /**
     * Operation createSubdomainWithHttpInfo
     *
     * Subdomain erstellen
     *
     * @param  \Mittwald\Api\Model\SubdomainCreationBody[] $body Daten der neuen Subdomain (required)
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     * @param  string $domain_identifier Vollständiger Name der Domain (required)
     *
     * @throws \Mittwald\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Mittwald\Api\Model\Subdomain[], HTTP status code, HTTP response headers (array of strings)
     */
    public function createSubdomainWithHttpInfo($body, $account_identifier, $domain_identifier)
    {
        $returnType = '\Mittwald\Api\Model\Subdomain[]';
        $request = $this->createSubdomainRequest($body, $account_identifier, $domain_identifier);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mittwald\Api\Model\Subdomain[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createSubdomainAsync
     *
     * Subdomain erstellen
     *
     * @param  \Mittwald\Api\Model\SubdomainCreationBody[] $body Daten der neuen Subdomain (required)
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     * @param  string $domain_identifier Vollständiger Name der Domain (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createSubdomainAsync($body, $account_identifier, $domain_identifier)
    {
        return $this->createSubdomainAsyncWithHttpInfo($body, $account_identifier, $domain_identifier)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createSubdomainAsyncWithHttpInfo
     *
     * Subdomain erstellen
     *
     * @param  \Mittwald\Api\Model\SubdomainCreationBody[] $body Daten der neuen Subdomain (required)
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     * @param  string $domain_identifier Vollständiger Name der Domain (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createSubdomainAsyncWithHttpInfo($body, $account_identifier, $domain_identifier)
    {
        $returnType = '\Mittwald\Api\Model\Subdomain[]';
        $request = $this->createSubdomainRequest($body, $account_identifier, $domain_identifier);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createSubdomain'
     *
     * @param  \Mittwald\Api\Model\SubdomainCreationBody[] $body Daten der neuen Subdomain (required)
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     * @param  string $domain_identifier Vollständiger Name der Domain (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createSubdomainRequest($body, $account_identifier, $domain_identifier)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createSubdomain'
            );
        }
        // verify the required parameter 'account_identifier' is set
        if ($account_identifier === null || (is_array($account_identifier) && count($account_identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_identifier when calling createSubdomain'
            );
        }
        // verify the required parameter 'domain_identifier' is set
        if ($domain_identifier === null || (is_array($domain_identifier) && count($domain_identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain_identifier when calling createSubdomain'
            );
        }

        $resourcePath = '/accounts/{accountIdentifier}/domains/{domainIdentifier}/subdomains';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'accountIdentifier' . '}',
                ObjectSerializer::toPathValue($account_identifier),
                $resourcePath
            );
        }
        // path params
        if ($domain_identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'domainIdentifier' . '}',
                ObjectSerializer::toPathValue($domain_identifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDomain
     *
     * Domain löschen/kündigen
     *
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     * @param  string $domain_identifier Vollständiger Name der Domain (required)
     *
     * @throws \Mittwald\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteDomain($account_identifier, $domain_identifier)
    {
        $this->deleteDomainWithHttpInfo($account_identifier, $domain_identifier);
    }

    /**
     * Operation deleteDomainWithHttpInfo
     *
     * Domain löschen/kündigen
     *
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     * @param  string $domain_identifier Vollständiger Name der Domain (required)
     *
     * @throws \Mittwald\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDomainWithHttpInfo($account_identifier, $domain_identifier)
    {
        $returnType = '';
        $request = $this->deleteDomainRequest($account_identifier, $domain_identifier);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteDomainAsync
     *
     * Domain löschen/kündigen
     *
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     * @param  string $domain_identifier Vollständiger Name der Domain (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDomainAsync($account_identifier, $domain_identifier)
    {
        return $this->deleteDomainAsyncWithHttpInfo($account_identifier, $domain_identifier)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDomainAsyncWithHttpInfo
     *
     * Domain löschen/kündigen
     *
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     * @param  string $domain_identifier Vollständiger Name der Domain (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDomainAsyncWithHttpInfo($account_identifier, $domain_identifier)
    {
        $returnType = '';
        $request = $this->deleteDomainRequest($account_identifier, $domain_identifier);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDomain'
     *
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     * @param  string $domain_identifier Vollständiger Name der Domain (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteDomainRequest($account_identifier, $domain_identifier)
    {
        // verify the required parameter 'account_identifier' is set
        if ($account_identifier === null || (is_array($account_identifier) && count($account_identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_identifier when calling deleteDomain'
            );
        }
        // verify the required parameter 'domain_identifier' is set
        if ($domain_identifier === null || (is_array($domain_identifier) && count($domain_identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain_identifier when calling deleteDomain'
            );
        }

        $resourcePath = '/accounts/{accountIdentifier}/domains/{domainIdentifier}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'accountIdentifier' . '}',
                ObjectSerializer::toPathValue($account_identifier),
                $resourcePath
            );
        }
        // path params
        if ($domain_identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'domainIdentifier' . '}',
                ObjectSerializer::toPathValue($domain_identifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteSubdomain
     *
     * Subdomain löschen
     *
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     * @param  string $domain_identifier Vollständiger Name der Domain (required)
     *
     * @throws \Mittwald\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteSubdomain($account_identifier, $domain_identifier)
    {
        $this->deleteSubdomainWithHttpInfo($account_identifier, $domain_identifier);
    }

    /**
     * Operation deleteSubdomainWithHttpInfo
     *
     * Subdomain löschen
     *
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     * @param  string $domain_identifier Vollständiger Name der Domain (required)
     *
     * @throws \Mittwald\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteSubdomainWithHttpInfo($account_identifier, $domain_identifier)
    {
        $returnType = '';
        $request = $this->deleteSubdomainRequest($account_identifier, $domain_identifier);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteSubdomainAsync
     *
     * Subdomain löschen
     *
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     * @param  string $domain_identifier Vollständiger Name der Domain (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSubdomainAsync($account_identifier, $domain_identifier)
    {
        return $this->deleteSubdomainAsyncWithHttpInfo($account_identifier, $domain_identifier)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteSubdomainAsyncWithHttpInfo
     *
     * Subdomain löschen
     *
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     * @param  string $domain_identifier Vollständiger Name der Domain (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSubdomainAsyncWithHttpInfo($account_identifier, $domain_identifier)
    {
        $returnType = '';
        $request = $this->deleteSubdomainRequest($account_identifier, $domain_identifier);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteSubdomain'
     *
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     * @param  string $domain_identifier Vollständiger Name der Domain (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteSubdomainRequest($account_identifier, $domain_identifier)
    {
        // verify the required parameter 'account_identifier' is set
        if ($account_identifier === null || (is_array($account_identifier) && count($account_identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_identifier when calling deleteSubdomain'
            );
        }
        // verify the required parameter 'domain_identifier' is set
        if ($domain_identifier === null || (is_array($domain_identifier) && count($domain_identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain_identifier when calling deleteSubdomain'
            );
        }

        $resourcePath = '/accounts/{accountIdentifier}/domains/{domainIdentifier}/subdomains';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'accountIdentifier' . '}',
                ObjectSerializer::toPathValue($account_identifier),
                $resourcePath
            );
        }
        // path params
        if ($domain_identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'domainIdentifier' . '}',
                ObjectSerializer::toPathValue($domain_identifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                []
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                [],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainProxyList
     *
     * Domain Proxies eines Accounts
     *
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     *
     * @throws \Mittwald\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Mittwald\Api\Model\DomainProxy[]
     */
    public function domainProxyList($account_identifier)
    {
        list($response) = $this->domainProxyListWithHttpInfo($account_identifier);
        return $response;
    }

    /**
     * Operation domainProxyListWithHttpInfo
     *
     * Domain Proxies eines Accounts
     *
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     *
     * @throws \Mittwald\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Mittwald\Api\Model\DomainProxy[], HTTP status code, HTTP response headers (array of strings)
     */
    public function domainProxyListWithHttpInfo($account_identifier)
    {
        $returnType = '\Mittwald\Api\Model\DomainProxy[]';
        $request = $this->domainProxyListRequest($account_identifier);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mittwald\Api\Model\DomainProxy[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainProxyListAsync
     *
     * Domain Proxies eines Accounts
     *
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainProxyListAsync($account_identifier)
    {
        return $this->domainProxyListAsyncWithHttpInfo($account_identifier)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainProxyListAsyncWithHttpInfo
     *
     * Domain Proxies eines Accounts
     *
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainProxyListAsyncWithHttpInfo($account_identifier)
    {
        $returnType = '\Mittwald\Api\Model\DomainProxy[]';
        $request = $this->domainProxyListRequest($account_identifier);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainProxyList'
     *
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function domainProxyListRequest($account_identifier)
    {
        // verify the required parameter 'account_identifier' is set
        if ($account_identifier === null || (is_array($account_identifier) && count($account_identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_identifier when calling domainProxyList'
            );
        }

        $resourcePath = '/accounts/{accountIdentifier}/domainsproxies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'accountIdentifier' . '}',
                ObjectSerializer::toPathValue($account_identifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDomainAuthCode
     *
     * Auth-Code einer Domain auslesen
     *
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     * @param  string $domain_identifier Vollständiger Name der Domain (required)
     *
     * @throws \Mittwald\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Mittwald\Api\Model\DomainAuthCode
     */
    public function getDomainAuthCode($account_identifier, $domain_identifier)
    {
        list($response) = $this->getDomainAuthCodeWithHttpInfo($account_identifier, $domain_identifier);
        return $response;
    }

    /**
     * Operation getDomainAuthCodeWithHttpInfo
     *
     * Auth-Code einer Domain auslesen
     *
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     * @param  string $domain_identifier Vollständiger Name der Domain (required)
     *
     * @throws \Mittwald\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Mittwald\Api\Model\DomainAuthCode, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDomainAuthCodeWithHttpInfo($account_identifier, $domain_identifier)
    {
        $returnType = '\Mittwald\Api\Model\DomainAuthCode';
        $request = $this->getDomainAuthCodeRequest($account_identifier, $domain_identifier);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mittwald\Api\Model\DomainAuthCode',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mittwald\Api\Model\Message',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDomainAuthCodeAsync
     *
     * Auth-Code einer Domain auslesen
     *
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     * @param  string $domain_identifier Vollständiger Name der Domain (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDomainAuthCodeAsync($account_identifier, $domain_identifier)
    {
        return $this->getDomainAuthCodeAsyncWithHttpInfo($account_identifier, $domain_identifier)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDomainAuthCodeAsyncWithHttpInfo
     *
     * Auth-Code einer Domain auslesen
     *
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     * @param  string $domain_identifier Vollständiger Name der Domain (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDomainAuthCodeAsyncWithHttpInfo($account_identifier, $domain_identifier)
    {
        $returnType = '\Mittwald\Api\Model\DomainAuthCode';
        $request = $this->getDomainAuthCodeRequest($account_identifier, $domain_identifier);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDomainAuthCode'
     *
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     * @param  string $domain_identifier Vollständiger Name der Domain (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDomainAuthCodeRequest($account_identifier, $domain_identifier)
    {
        // verify the required parameter 'account_identifier' is set
        if ($account_identifier === null || (is_array($account_identifier) && count($account_identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_identifier when calling getDomainAuthCode'
            );
        }
        // verify the required parameter 'domain_identifier' is set
        if ($domain_identifier === null || (is_array($domain_identifier) && count($domain_identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain_identifier when calling getDomainAuthCode'
            );
        }

        $resourcePath = '/accounts/{accountIdentifier}/domains/{domainIdentifier}/authcode';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'accountIdentifier' . '}',
                ObjectSerializer::toPathValue($account_identifier),
                $resourcePath
            );
        }
        // path params
        if ($domain_identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'domainIdentifier' . '}',
                ObjectSerializer::toPathValue($domain_identifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getToplevelDomain
     *
     * Toplevel-Domain auslesen
     *
     * @param  string $top_level_domain_identifier Topleveldomain (required)
     * @param  string $fields Auszuliefernde Felder, als kommaseparierte Liste. (optional)
     *
     * @throws \Mittwald\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Mittwald\Api\Model\TopLevelDomain
     */
    public function getToplevelDomain($top_level_domain_identifier, $fields = null)
    {
        list($response) = $this->getToplevelDomainWithHttpInfo($top_level_domain_identifier, $fields);
        return $response;
    }

    /**
     * Operation getToplevelDomainWithHttpInfo
     *
     * Toplevel-Domain auslesen
     *
     * @param  string $top_level_domain_identifier Topleveldomain (required)
     * @param  string $fields Auszuliefernde Felder, als kommaseparierte Liste. (optional)
     *
     * @throws \Mittwald\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Mittwald\Api\Model\TopLevelDomain, HTTP status code, HTTP response headers (array of strings)
     */
    public function getToplevelDomainWithHttpInfo($top_level_domain_identifier, $fields = null)
    {
        $returnType = '\Mittwald\Api\Model\TopLevelDomain';
        $request = $this->getToplevelDomainRequest($top_level_domain_identifier, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mittwald\Api\Model\TopLevelDomain',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getToplevelDomainAsync
     *
     * Toplevel-Domain auslesen
     *
     * @param  string $top_level_domain_identifier Topleveldomain (required)
     * @param  string $fields Auszuliefernde Felder, als kommaseparierte Liste. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getToplevelDomainAsync($top_level_domain_identifier, $fields = null)
    {
        return $this->getToplevelDomainAsyncWithHttpInfo($top_level_domain_identifier, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getToplevelDomainAsyncWithHttpInfo
     *
     * Toplevel-Domain auslesen
     *
     * @param  string $top_level_domain_identifier Topleveldomain (required)
     * @param  string $fields Auszuliefernde Felder, als kommaseparierte Liste. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getToplevelDomainAsyncWithHttpInfo($top_level_domain_identifier, $fields = null)
    {
        $returnType = '\Mittwald\Api\Model\TopLevelDomain';
        $request = $this->getToplevelDomainRequest($top_level_domain_identifier, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getToplevelDomain'
     *
     * @param  string $top_level_domain_identifier Topleveldomain (required)
     * @param  string $fields Auszuliefernde Felder, als kommaseparierte Liste. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getToplevelDomainRequest($top_level_domain_identifier, $fields = null)
    {
        // verify the required parameter 'top_level_domain_identifier' is set
        if ($top_level_domain_identifier === null || (is_array($top_level_domain_identifier) && count($top_level_domain_identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $top_level_domain_identifier when calling getToplevelDomain'
            );
        }

        $resourcePath = '/topleveldomains/{topLevelDomainIdentifier}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields, null);
        }

        // path params
        if ($top_level_domain_identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'topLevelDomainIdentifier' . '}',
                ObjectSerializer::toPathValue($top_level_domain_identifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listDomainsByAccount
     *
     * Domains eines Accounts auslesen
     *
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     * @param  int $limit Anzahl der zurückzuliefernden Domains. (optional, default to 20)
     * @param  int $offset Offset für die Limitierung der Suchergebnisse (optional, default to 0)
     *
     * @throws \Mittwald\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Mittwald\Api\Model\Domain[]
     */
    public function listDomainsByAccount($account_identifier, $limit = '20', $offset = '0')
    {
        list($response) = $this->listDomainsByAccountWithHttpInfo($account_identifier, $limit, $offset);
        return $response;
    }

    /**
     * Operation listDomainsByAccountWithHttpInfo
     *
     * Domains eines Accounts auslesen
     *
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     * @param  int $limit Anzahl der zurückzuliefernden Domains. (optional, default to 20)
     * @param  int $offset Offset für die Limitierung der Suchergebnisse (optional, default to 0)
     *
     * @throws \Mittwald\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Mittwald\Api\Model\Domain[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listDomainsByAccountWithHttpInfo($account_identifier, $limit = '20', $offset = '0')
    {
        $returnType = '\Mittwald\Api\Model\Domain[]';
        $request = $this->listDomainsByAccountRequest($account_identifier, $limit, $offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mittwald\Api\Model\Domain[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mittwald\Api\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listDomainsByAccountAsync
     *
     * Domains eines Accounts auslesen
     *
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     * @param  int $limit Anzahl der zurückzuliefernden Domains. (optional, default to 20)
     * @param  int $offset Offset für die Limitierung der Suchergebnisse (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listDomainsByAccountAsync($account_identifier, $limit = '20', $offset = '0')
    {
        return $this->listDomainsByAccountAsyncWithHttpInfo($account_identifier, $limit, $offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listDomainsByAccountAsyncWithHttpInfo
     *
     * Domains eines Accounts auslesen
     *
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     * @param  int $limit Anzahl der zurückzuliefernden Domains. (optional, default to 20)
     * @param  int $offset Offset für die Limitierung der Suchergebnisse (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listDomainsByAccountAsyncWithHttpInfo($account_identifier, $limit = '20', $offset = '0')
    {
        $returnType = '\Mittwald\Api\Model\Domain[]';
        $request = $this->listDomainsByAccountRequest($account_identifier, $limit, $offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listDomainsByAccount'
     *
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     * @param  int $limit Anzahl der zurückzuliefernden Domains. (optional, default to 20)
     * @param  int $offset Offset für die Limitierung der Suchergebnisse (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listDomainsByAccountRequest($account_identifier, $limit = '20', $offset = '0')
    {
        // verify the required parameter 'account_identifier' is set
        if ($account_identifier === null || (is_array($account_identifier) && count($account_identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_identifier when calling listDomainsByAccount'
            );
        }

        $resourcePath = '/accounts/{accountIdentifier}/domains';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, null);
        }
        // query params
        if ($offset !== null) {
            $queryParams['offset'] = ObjectSerializer::toQueryValue($offset, null);
        }

        // path params
        if ($account_identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'accountIdentifier' . '}',
                ObjectSerializer::toPathValue($account_identifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listSubdomainsByDomain
     *
     * Subdomains eines Accounts auslesen
     *
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     * @param  string $domain_identifier Vollständiger Name der Domain (required)
     *
     * @throws \Mittwald\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Mittwald\Api\Model\Subdomain[]
     */
    public function listSubdomainsByDomain($account_identifier, $domain_identifier)
    {
        list($response) = $this->listSubdomainsByDomainWithHttpInfo($account_identifier, $domain_identifier);
        return $response;
    }

    /**
     * Operation listSubdomainsByDomainWithHttpInfo
     *
     * Subdomains eines Accounts auslesen
     *
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     * @param  string $domain_identifier Vollständiger Name der Domain (required)
     *
     * @throws \Mittwald\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Mittwald\Api\Model\Subdomain[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listSubdomainsByDomainWithHttpInfo($account_identifier, $domain_identifier)
    {
        $returnType = '\Mittwald\Api\Model\Subdomain[]';
        $request = $this->listSubdomainsByDomainRequest($account_identifier, $domain_identifier);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mittwald\Api\Model\Subdomain[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listSubdomainsByDomainAsync
     *
     * Subdomains eines Accounts auslesen
     *
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     * @param  string $domain_identifier Vollständiger Name der Domain (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listSubdomainsByDomainAsync($account_identifier, $domain_identifier)
    {
        return $this->listSubdomainsByDomainAsyncWithHttpInfo($account_identifier, $domain_identifier)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listSubdomainsByDomainAsyncWithHttpInfo
     *
     * Subdomains eines Accounts auslesen
     *
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     * @param  string $domain_identifier Vollständiger Name der Domain (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listSubdomainsByDomainAsyncWithHttpInfo($account_identifier, $domain_identifier)
    {
        $returnType = '\Mittwald\Api\Model\Subdomain[]';
        $request = $this->listSubdomainsByDomainRequest($account_identifier, $domain_identifier);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listSubdomainsByDomain'
     *
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     * @param  string $domain_identifier Vollständiger Name der Domain (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listSubdomainsByDomainRequest($account_identifier, $domain_identifier)
    {
        // verify the required parameter 'account_identifier' is set
        if ($account_identifier === null || (is_array($account_identifier) && count($account_identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_identifier when calling listSubdomainsByDomain'
            );
        }
        // verify the required parameter 'domain_identifier' is set
        if ($domain_identifier === null || (is_array($domain_identifier) && count($domain_identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain_identifier when calling listSubdomainsByDomain'
            );
        }

        $resourcePath = '/accounts/{accountIdentifier}/domains/{domainIdentifier}/subdomains';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'accountIdentifier' . '}',
                ObjectSerializer::toPathValue($account_identifier),
                $resourcePath
            );
        }
        // path params
        if ($domain_identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'domainIdentifier' . '}',
                ObjectSerializer::toPathValue($domain_identifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listToplevelDomains
     *
     * Toplevel-Domains auslesen
     *
     *
     * @throws \Mittwald\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Mittwald\Api\Model\TopLevelDomain[]
     */
    public function listToplevelDomains()
    {
        list($response) = $this->listToplevelDomainsWithHttpInfo();
        return $response;
    }

    /**
     * Operation listToplevelDomainsWithHttpInfo
     *
     * Toplevel-Domains auslesen
     *
     *
     * @throws \Mittwald\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Mittwald\Api\Model\TopLevelDomain[], HTTP status code, HTTP response headers (array of strings)
     */
    public function listToplevelDomainsWithHttpInfo()
    {
        $returnType = '\Mittwald\Api\Model\TopLevelDomain[]';
        $request = $this->listToplevelDomainsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mittwald\Api\Model\TopLevelDomain[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listToplevelDomainsAsync
     *
     * Toplevel-Domains auslesen
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listToplevelDomainsAsync()
    {
        return $this->listToplevelDomainsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listToplevelDomainsAsyncWithHttpInfo
     *
     * Toplevel-Domains auslesen
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listToplevelDomainsAsyncWithHttpInfo()
    {
        $returnType = '\Mittwald\Api\Model\TopLevelDomain[]';
        $request = $this->listToplevelDomainsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listToplevelDomains'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listToplevelDomainsRequest()
    {

        $resourcePath = '/topleveldomains';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation registerNewDomain
     *
     * Domain registrieren/Transfer einleiten
     *
     * @param  \Mittwald\Api\Model\DomainRegistration $body Daten für eine Domain-Registrierung (required)
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     *
     * @throws \Mittwald\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Mittwald\Api\Model\Domain[]
     */
    public function registerNewDomain($body, $account_identifier)
    {
        list($response) = $this->registerNewDomainWithHttpInfo($body, $account_identifier);
        return $response;
    }

    /**
     * Operation registerNewDomainWithHttpInfo
     *
     * Domain registrieren/Transfer einleiten
     *
     * @param  \Mittwald\Api\Model\DomainRegistration $body Daten für eine Domain-Registrierung (required)
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     *
     * @throws \Mittwald\Api\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Mittwald\Api\Model\Domain[], HTTP status code, HTTP response headers (array of strings)
     */
    public function registerNewDomainWithHttpInfo($body, $account_identifier)
    {
        $returnType = '\Mittwald\Api\Model\Domain[]';
        $request = $this->registerNewDomainRequest($body, $account_identifier);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Mittwald\Api\Model\Domain[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation registerNewDomainAsync
     *
     * Domain registrieren/Transfer einleiten
     *
     * @param  \Mittwald\Api\Model\DomainRegistration $body Daten für eine Domain-Registrierung (required)
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function registerNewDomainAsync($body, $account_identifier)
    {
        return $this->registerNewDomainAsyncWithHttpInfo($body, $account_identifier)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation registerNewDomainAsyncWithHttpInfo
     *
     * Domain registrieren/Transfer einleiten
     *
     * @param  \Mittwald\Api\Model\DomainRegistration $body Daten für eine Domain-Registrierung (required)
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function registerNewDomainAsyncWithHttpInfo($body, $account_identifier)
    {
        $returnType = '\Mittwald\Api\Model\Domain[]';
        $request = $this->registerNewDomainRequest($body, $account_identifier);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'registerNewDomain'
     *
     * @param  \Mittwald\Api\Model\DomainRegistration $body Daten für eine Domain-Registrierung (required)
     * @param  string $account_identifier Name oder ID eines Accounts (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function registerNewDomainRequest($body, $account_identifier)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling registerNewDomain'
            );
        }
        // verify the required parameter 'account_identifier' is set
        if ($account_identifier === null || (is_array($account_identifier) && count($account_identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_identifier when calling registerNewDomain'
            );
        }

        $resourcePath = '/accounts/{accountIdentifier}/domains';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($account_identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'accountIdentifier' . '}',
                ObjectSerializer::toPathValue($account_identifier),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['*/*']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
